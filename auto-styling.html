<!--

  This is an experiment in auto-styling dataset visualizations based on auto-detected datatypes.

  Example dataset:
  http://192.168.1.108:8080/auto-styling.html?dataset=8581a7460e144ae09ad25d47f8e82af8_0


-->

<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta
  name="viewport"
  content="initial-scale=1,maximum-scale=1,user-scalable=no"
  />
  <title>Filters</title>
  <link href="auto-styling.css" rel="stylesheet">

  <script src="https://unpkg.com/lodash@4.17.15/lodash.js"></script>

  <!-- <link rel="stylesheet" href="https://s3-us-west-1.amazonaws.com/patterns.esri.com/files/calcite-web/1.2.5/css/calcite-web.min.css"> -->
  <!-- <script src="https://s3-us-west-1.amazonaws.com/patterns.esri.com/files/calcite-web/1.2.5/js/calcite-web.min.js"></script> -->

  <!-- calcite components -->
  <script
  type="module"
  src="https://unpkg.com/@esri/calcite-components@1.0.0-beta.24/dist/calcite/calcite.esm.js"
  ></script>
  <link
  rel="stylesheet"
  type="text/css"
  href="https://unpkg.com/@esri/calcite-components@1.0.0-beta.24/dist/calcite/calcite.css"
  />

  <!-- Load d3.js -->
  <script src="https://d3js.org/d3.v4.js"></script>

  <!-- Load jStat -->
  <script src="https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js"></script>

  <script type="module">

    import { loadModules, setDefaultOptions } from 'https://unpkg.com/esri-loader/dist/esm/esri-loader.js';

    (async () => {

      setDefaultOptions({
        css: true,
        // url: 'http://localhost:8000/buildOutput/init.js',
        // url: 'https://jscore.esri.com/debug/4.16/dojo/dojo.js',
        // version: 'next',
      });

      const [
      Map,
      MapView,
      FeatureLayer,
      generateHistogram,
      Histogram,
      HistogramRangeSlider,
      TimeSlider,
      SimpleMarker,
      uniqueValues,
      webMercatorUtils,
      Legend,
      Renderer,
      jsonUtils,
      colorRamps,
      Color,
      ] = await loadModules([
      "esri/Map",
      "esri/views/MapView",
      "esri/layers/FeatureLayer",
      "esri/renderers/smartMapping/statistics/histogram",
      "esri/widgets/Histogram",
      "esri/widgets/HistogramRangeSlider",
      "esri/widgets/TimeSlider",
      "esri/symbols/SimpleMarkerSymbol",
      "esri/renderers/smartMapping/statistics/uniqueValues",
      "esri/geometry/support/webMercatorUtils",
      "esri/widgets/Legend",
      "esri/renderers/Renderer",
      "esri/renderers/support/jsonUtils",
      "esri/renderers/smartMapping/symbology/support/colorRamps",
      "esri/Color",
      ]);


      // data urls
      var datasets = {
        'Citclops Water': "8581a7460e144ae09ad25d47f8e82af8_0",
        'Seattle Bike Facilities': "f4f509fa13504fb7957cef168fad74f0_1",
        'Tucson Demographics': "35fda63efad14a7b8c2a0a68d77020b7_0",
        'Traffic Circles': "717b10434d4945658355eba78b66971a_6",
        'Black Cat Range': "28b0a8a0727d4cc5a2b9703cf6ca4425_0",
        'King County Photos': "383878300c4c4f8c940272ba5bfcce34_1036",
        'NYC bags': "7264acdf886941199f7c01648ba04e6b_0",
      }

      // dataset switcher
      var datasetList = document.getElementById('datasetList');
      for (let [key, value] of Object.entries(datasets)) {
        // create new option element and add it to the dropdown
        var opt = document.createElement('option');
        opt.text = key;
        opt.value = value;
        datasetList.appendChild(opt);
      }

      datasetList.addEventListener('change', async event => {
        ({ layer, dataset } = await loadDataset({ datasetId: event.target.value, env: 'prod' }));
        drawMap(layer, dataset);
      });

      // color ramp switcher
      var rampList = document.getElementById('rampList');
      const allRamps = colorRamps.all();
      for (let [key, value] of Object.entries(allRamps)) {
        // create new option element and add it to the dropdown
        var opt = document.createElement('option');
        opt.text = value.name;
        opt.value = value.name;
        rampList.appendChild(opt);
      }

      // set ramp list event handler
      rampList.addEventListener('change', async event => {
        var ramp = colorRamps.byName(event.target.value);
        updateRamp(ramp.colors, layer);
      });

      // track widgets and state
      var timeSlider = null;
      var dataset = null;
      var layer = null;
      // var zoomToDataCheckbox;
      var attributeList;

      // URL params
      const params = new URLSearchParams(window.location.search);
      var env = 'prod';
      if (Array.from(params).length != 0) {
        var datasetId = params.get('dataset');
        const datasetSlug = params.get('slug');
        ({ layer, dataset } = await loadDataset({ datasetId: datasetId, datasetSlug: datasetSlug, env: env }));
        env = params.get('env');
      } else {
        var datasetId = datasetList.options[datasetList.selectedIndex].value;
        ({ layer, dataset } = await loadDataset({ datasetId: datasetId, env: env }));
        if (!layer.loaded) {
          layer.on("layerview-create", function(event){

          });
        }
      }

      // add event listener to dropdown, to create visualizations
      attributeList.addEventListener('calciteDropdownItemSelected', switchSelected);
      async function switchSelected (event, fieldName = null) {
        fieldName = fieldName ? fieldName : event.target.getAttribute('data-field');
        const field = getDatasetField(dataset, fieldName);
        document.querySelector('#attributeListButton').innerHTML = fieldName;

        // Reset UI state

        // stop timeSlider playback
        if (timeSlider && timeSlider.widget) {
          timeSlider.widget.stop();
          timeSlider = null;
        }

        document.getElementById('widget').innerHTML = ''; // clear previous widget
        document.getElementById('widgetMessage').innerHTML = ''; // clear previous message

        // guess at a style for this field
        try {
          if (!layer) { // if there's no layer
            // initialize a new one
            layer = new FeatureLayer({
              renderer: {type: 'simple'},
              url: dataset.attributes.url
            });
          }
          if (!layer?.loaded) { // if the layer isn't loaded yet
            // wait for layer to load
            layer.on("layerview-create", async () => {
              switchStyles(layer, fieldName);
            });
          } else {
            switchStyles(layer, fieldName);
          }
        } catch(e) {
          console.log('e:', e)
        }

        // if (predefinedStyle) {
        //   layer = await new FeatureLayer({
        //     renderer: jsonUtils.fromJSON(predefinedStyle.renderer),
        //     url: dataset.attributes.url
        //   });
        // } else {
        // // otherwise do nothing, and the FeatureLayer constructor makes it own
        //   layer = await new FeatureLayer({
        //     url: dataset.attributes.url
        //   });
        // }

        // createSmartMapRenderer(layer, field, view);

      }

        async function switchStyles(layer, fieldName) {
          console.log('switchStyles')
          widgetMessage.innerText = 'Drawing '+fieldName+'.';

          var layerView = layer.view;
          var renderer = await autoStyle(fieldName, dataset);
          const field = getDatasetField(dataset, fieldName);
          layer.renderer = renderer;
          layer.minScale = 0; // draw at all scales
          layer.outFields = ["*"]; // get all fields (easier for prototyping, optimize by managing for necessary fields)

          // clear previous filters
          if (typeof layerView != 'undefined') {
            // updateLayerViewEffect(layerView, { where: null, updateExtent: zoomToDataCheckbox.checked });
            updateLayerViewEffect(layerView, { where: null, updateExtent: true });
          }

          // Numeric fields - histogram
          if (field.simpleType === 'numeric') {// || field.simpleType === 'date') {
            widgetMessage.innerText += '\nLooks like numbers.';
            // Histogram
            const container = document.createElement('div');
            container.classList.add('histogramWidget');
            document.getElementById('widget').appendChild(container);

            const histogramSlider = await createHistogram({ dataset, fieldName, layer, layerView, container, slider: true });
            if (histogramSlider.widget) {
              if (histogramSlider.coverage < 1) {
                widgetMessage.innerText += '\nGraph values are approximate';
              }

              histogramSlider.widget.on(["thumb-change", "thumb-drag", "segment-drag"], event => {
                updateLayerViewWithHistogram(layerView, fieldName, histogramSlider.widget);
              });
            }
          }

          // Date fields - time slider
          else if (field.simpleType === 'date') {
            widgetMessage.innerText += '\nLooks likes dates.';
            // Time slider
            const container = document.createElement('div');
            container.classList.add('timesliderWidget');
            document.getElementById('widget').appendChild(container);

            timeSlider = await createTimeSlider({ dataset, fieldName, layerView, container });
            // set widget state
            if (timeSlider.widget) {

              // add a nested histogram
              const histogramContainer = document.createElement('div');
              histogramContainer.classList.add('miniHistogramWidget');
              container.getElementsByClassName("esri-slider__track")[0].after(histogramContainer);

              const miniHistogram = await createHistogram ({ dataset, fieldName, layer, layerView, container: histogramContainer });

              timeSlider.widget.watch("timeExtent", function(value){
                // convert Date to unix time stamp with unary + operator
                const where = `${fieldName} BETWEEN ${+new Date(value.start)} AND ${+new Date(value.end)}`;
                // update layer view filter to reflect current timeExtent
                updateLayerViewEffect(layerView, { where });
              });
            }
          }
          else {
            widgetMessage.innerText += '\nNot sure what datatype this field is.';
          }
        };


      drawMap(layer, dataset)

      async function drawMap(layer, dataset) {
        const map = new Map({
          basemap: "dark-gray-vector",
          layers: layer
        });
        const view = new MapView({
          container: "viewDiv",
          map: map,
          extent: getDatasetExtent(dataset)
        });
        const layerView = await view.whenLayerView(layer);

        // On-map UI widgets
        view.ui.move('zoom', 'top-right');
        // view.ui.add('zoomToData', 'bottom-right');
        view.ui.add('messageDiv', 'top-left');
        // zoomToDataCheckbox = document.querySelector('#zoomToData calcite-checkbox');
        // zoomToDataCheckbox.addEventListener('calciteCheckboxChange', () => {
        //   updateLayerViewEffect(layerView, { updateExtent: zoomToDataCheckbox.checked });
        // });

        var legend = await new Legend({
          view: view,
          layerInfos: [{
            layer: layer,
            title: "Legend"
          }]
        });
        view.ui.add(legend, "bottom-right");

        // put vars on window for debugging
        Object.assign(window, { view, map, dataset, layer, layerView, getDatasetField, getDatasetFieldUniqueValues, /*histogram, histogramValues,*/ generateHistogram, HistogramRangeSlider, uniqueValues });

        // update layerview filter based on histogram widget, debounced
        const updateLayerViewWithHistogram = _.throttle(
        (layerView, fieldName, histogramWidget) => {
          // updateLayerViewEffect(layerView, { where: histogramWidget.generateWhereClause(fieldName), updateExtent: zoomToDataCheckbox.checked });
          updateLayerViewEffect(layerView, { where: histogramWidget.generateWhereClause(fieldName), updateExtent: true });
        },
        50
        );

        // Dataset info
        document.querySelector('#datasetName').innerHTML = dataset.attributes.name;
        document.querySelector('#orgName').innerHTML = dataset.attributes.orgName || '';
        document.querySelector('#recordCount').innerHTML = `${dataset.attributes.recordCount} records`;
      }

      async function loadDataset (args) {
        if (args.url) { // dataset url provided directly
          const datasetURL = args.url;
          try {
            // dataset = (await fetch(datasetURL).then(r => r.json()));
            dataset = {attributes: {url: args.url}}
          } catch(e) { console.log('failed to load dataset from url:', args.url, e); }
        } else if (args.datasetId) { // dataset id provided directly
          // https://opendataqa.arcgis.com/api/v3/datasets/97a641ac39904f349fb5fc25b94207f6
          const datasetURL = `https://opendata${args.env === 'qa' ? 'qa' : ''}.arcgis.com/api/v3/datasets/${args.datasetId}`;
          try {
            dataset = (await fetch(datasetURL).then(r => r.json())).data;
          } catch(e) { console.log('failed to load dataset from id', args.datasetId, e); }
        } else if (args.datasetSlug) { // dataset slug provided as alternate
          // https://opendata.arcgis.com/api/v3/datasets?filter%5Bslug%5D=kingcounty%3A%3Aphoto-centers-for-2010-king-county-orthoimagery-project-ortho-image10-point
          const filter = `${encodeURIComponent('filter[slug]')}=${encodeURIComponent(args.datasetSlug)}`
          const datasetURL = `https://opendata${args.env === 'qa' ? 'qa' : ''}.arcgis.com/api/v3/datasets?${filter}`;
          try {
            dataset = (await fetch(datasetURL).then(r => r.json())).data[0];
          } catch(e) { console.log('failed to load dataset from slug', args.datasetSlug, e); }
        }

        attributeList = updateAttributeList(dataset)

        let predefinedStyle = dataset.attributes?.layer?.drawingInfo;

        var renderer;
        let fieldName = Object.keys(dataset.attributes.statistics.numeric)[0]
        let field = getDatasetField(dataset, fieldName)
        switchSelected(null, field.name);

        return { dataset, layer };
      }

      // analyze a dataset and choose an initial best-guess symbology for it
      async function autoStyle(fieldName, dataset) {
        const geometryType = dataset.attributes.geometryType;
        var field = getDatasetField(dataset, fieldName);
        let datasetStats = dataset.attributes.statistics.numeric[fieldName.toLowerCase()].statistics;
        let fieldStats = field.statistics;
        let minValue = fieldStats.values.min;
        let maxValue = fieldStats.values.max;
        let symbol;

        widgetMessage.innerText += '\nAnalyzing field \''+fieldName+'\'.';
        bigBoard(`Analyzing '${fieldName}'`, false);
        widgetMessage.innerText += '\nGeometry type is '+geometryType+'.';
        bigBoard(`Geometry type is ${geometryType}`);

        if (!!layer) {

          var query = layer.createQuery();
          // query.outFields = [fieldName]
          try {
            let uniqueValues = (await getDatasetFieldUniqueValues(dataset, fieldName, layer)).values;
            let domain = [Math.min(...uniqueValues.map(a => a.value)),
                          Math.max(...uniqueValues.map(a => a.value))]
            // remove nulls
            var filtered = uniqueValues.filter(a => a.value != null);
            // manually reconstruct a feature values array from the unique values and their counts -

            // normalize array length to 1000, as precision isn't as important as speed here
            // const divisor = dataset.attributes.recordCount / 1000;

            // use the whole set
            const divisor = 1;
            let arr = [];
            for (let x = 0; x < filtered.length; x++) {
              for (let y = 0; y < Math.ceil(filtered[x].count/divisor); y++) {
                arr.push(filtered[x].value);
              };
            }
            // use d3 to bin histograms
            let d3bins = d3.histogram()  // create layout object
              .domain([Math.min(...filtered.map(a => a.value)),
              Math.max(...filtered.map(a => a.value))])  // to cover range
              .thresholds(29) // separated into 30 bins
              (arr);          // pass the array
            // convert the d3 bins array to a bins object
            var bins = [];
            for (let x = 0; x < d3bins.length; x++) {
              bins.push({
                minValue: d3bins[x]['x0'],
                maxValue: d3bins[x]['x1'],
                count: d3bins[x].length,
              });
            }
            // put the bins in the params object
            var values = {
              'bins': bins,
              'minValue': Math.min(...filtered.map(a => a.value)),
              'maxValue': Math.max(...filtered.map(a => a.value)),
            }
            const featureCount = arr.length;
            var source = 'layerQuery';
            var coverage = 1;
          } catch(e) {
            // histogram generation failed with unique values, try using features in layer view
            console.log('histogram generation failed with unique values, try using features in layer view:');
            console.error(new Error(e));
            if (typeof layerView != 'undefined') {
              const { features } = await layerView.queryFeatures();
              const featureCount = await layer.queryFeatureCount();
              var values = await generateHistogram(params);
              var source = 'layerView';
              var coverage = params.features.length / featureCount;
            } else {
              console.warn('No layerView')
            }
          }

          var {features} = await layer.queryFeatures(query);

          if (features) {
            // debugger
            var values = Object.values(features).map(v => v.attributes[fieldName])
            var distribution = getDistribution(values, datasetStats.values);
            widgetMessage.innerHTML += '<br>'+distribution.message+'.';
          } else {
            console.log('no features returned for', fieldName)
          }

        }

        if (geometryType === 'esriGeometryPoint') {
          let stats = dataset.attributes.statistics
          // scale point size based on viewport size, number of points, and "clumpiness" of the data,
          // in order to reduce overlap of points

          // if there's still a lot of points, adjust opacity to show points through each other

          // pick a color scheme based on distribution of the data:
          // if a linear distribution, choose a linear–
          // if a log or exp distribution, choose log or exp –
          // if a normal distribution or something similar, choose "extremes"

          // choose colors based on background theme – dark on light, light on dark

        }


        else if (geometryType === 'esriGeometryPolyline') {
          symbol = {type: 'simple-line', width: '4px' };
        }

        else if (geometryType === 'esriGeometryPolygon') {
          symbol = {type: 'simple-fill' };
        }

        let allRamps = colorRamps.all();
        let ramp = allRamps[Math.floor(Math.random()*allRamps.length)];
        let rampColors = ramp.colors;

        // v simple way to vary point size with number of data points
        // 1-9: 20px
        // 10-99: 10px
        // 100-999: 5px
        // 1000-9999: 2.5px
        var pointSize = 20/(datasetStats.values.count+'').length; // convert to string to get power of 10

        symbol = {
          type: "simple-marker",
          outline: {
            // makes the outlines of all features consistently light gray
            color: "lightgray",
            width: 0.15*pointSize
          },
          size: pointSize+'px'
        }

        widgetMessage.innerText += '\nShowing '+fieldStats.values.count+' '+field.simpleType+' values.';

        var renderer = {
          type: "simple", // autocasts as new SimpleRenderer()
          symbol: symbol,
          // label: "% population in poverty by county", // label for the legend
          visualVariables: [{
            type: "color", // indicates this is a color visual variable
            field: fieldName,
            // normalizationField: "TOTPOP_CY", // total population
            stops: [{
              value: minValue,
              color: rampColors[0],
              label: minValue
            },{
              value: maxValue,
              color: rampColors[rampColors.length-1],
              label: maxValue
            }]
          }]
        };
        widgetMessage.innerText += '\nUsing colors from '+rampColors[0]+' to '+rampColors[rampColors.length-1]+'.';
        widgetMessage.innerHTML += '<br><br>';
        return renderer;
      }

      function updateRamp(rampColors, layer) {
        let renderer = layer.renderer.clone();
        renderer.visualVariables[0].stops[0].color = rampColors[0];
        renderer.visualVariables[0].stops[1].color = rampColors[rampColors.length-1];
        layer.renderer = renderer;
        return renderer;
      }

      function getDistribution(values, stats) {
        // debugger
        let msg = [];
        let js = jStat(values)
        let uniqueValues = new Set(values);

        if (stats) {
          var min = stats.min;
          var max = stats.max;
          var midpoint = max-min/2;
          var range = max-min; // distance between min and max
          var mean = stats.avg;
          var variance = stats.var;
          var stdev = stats.stddev;
          var count = stats.count;
        } else {
          var min = jStat.min(values);
          var max = jStat.max(values);
          var midpoint = max-min/2;
          var range = max-min; // distance between min and max
          var mean = jStat.mean(values);
          var variance = jStat.variance(values);
          var stdev = jStat.stdev(values);
          var count = values.length;
        }

        let sampleCount = values.length;
        let mode = jStat.mode(values);
        let meddev = jStat.meddev(values); // median absolute deviation
        let quartiles = jStat.quartiles(values);
        let IQR = quartiles[2]-quartiles[0];

        msg.push('Sample count: '+sampleCount)
        msg.push('Min: '+min+', Max: '+max+', Range:'+range)
        msg.push('Mean: '+mean)
        msg.push('IQR: '+IQR)
        msg.push('IQR/range: '+ (IQR/range))
        let clustered = IQR/range;
        if (! clustered || clustered < .1) msg.push('highly clustered')
        else if (clustered < .25) msg.push('a bit clustered')
        else if (clustered < .5) msg.push('roughly uniform')
        else if (clustered < .75) msg.push('a bit dispersed')
        else msg.push('highly dispersed')
        bigBoard(msg[msg.length-1]);

        let uniquesCount = uniqueValues.size;
        let uniqueness = uniqueValues.size/values.length;
        msg.push('uniqueness: '+uniqueness)
        if (uniquesCount === 1) {
          msg.push('no unique values')
        } else {
            if (uniqueness < .25) msg.push('very few unique values ('+uniquesCount+')')
            else if (uniqueness < .5) msg.push('few unique values')
            else if (uniqueness < .75) msg.push('few repeated values')
            else if (uniqueness < 1) msg.push('very vew repeated values')
            else msg.push('no repeated values')
        }
        bigBoard(msg[msg.length-1]);

        if (uniqueness != 1) {
          if (!!mode) {
            if (typeof mode === "Array") {
              msg.push(mode.length+" Modes")
            } else {
              msg.push('Mode: '+mode);
            }
            msg.push('Meddev: '+meddev)
            if (mode.length == 2) {
              msg.push('with two modes')
            } else if (mode.length > 5) {
              msg.push('with '+mode.length+' modes')
            }
          }
        }

        let meanLocation = (mean-min)/range; // how far along in the range is the mean? subtract min to account for offsets
        msg.push('meanLocation: '+meanLocation)
        if (!!meanLocation) {
          if (meanLocation < .3) msg.push('skewed low')
          else if (meanLocation < .45) msg.push('skewed a bit low')
          else if (meanLocation < .55) msg.push('roughly symmetrical')
          else if (meanLocation < .7) msg.push('skewed a bit high')
          else msg.push('skewed high')
          bigBoard(msg[msg.length-1]);

          if ((mode === min && meanLocation < .25) || (mode === max && meanLocation > .5)) {
            msg.push('possibly exponential')
          } else if ((mode === min && meanLocation > .75) || (mode === max && meanLocation < .5)) {
            msg.push('possibly logarithmic')
          }
        }

        let variability = meddev/range;
        msg.push('Variablility:'+variability)
        if (!!variability) {
          if (variability < .2) msg.push('highly regular')
          else if (variability < .4) msg.push('generally regular')
          else if (variability < .6) msg.push('slightly variable')
          else if (variability < .8) msg.push('moderately variable')
          else msg.push('highly variable')
        } else {
            msg.push('with very little apparent variability')
        }
        bigBoard(msg[msg.length-1]);

        msg[msg.length-1] = 'and '+msg[msg.length-1];
        msg = msg.join('<br>');
        return {
          message: msg,
          stats: {
            min: min,
            max: max,
            mode: mode,
            uniqueness: uniqueness,
            variability: variability,
            meanLocation: meanLocation,
            clustered: clustered,
            mode: mode,
          }
        }
      }

      window.getDistribution = getDistribution;

      function loadRenderer (type, props) {
        return loadModules(
        [`esri/renderers/smartMapping/creators/${type}`]
        ).then(([rendererCreator]) => {
          const creatorFn = type === 'color'
          ? 'createContinuousRenderer'
          : type === 'size'
          ? 'createContinuousRenderer' // 'createClassBreaksRenderer'
          : 'createRenderer';
          return rendererCreator[creatorFn](props)
          .then(response => response.renderer);
        });
      }

      function getDatasetExtent (dataset) {
        const extent = dataset.attributes.extent;
        return {
          xmin: extent.coordinates[0][0],
          ymin: extent.coordinates[0][1],
          xmax: extent.coordinates[1][0],
          ymax: extent.coordinates[1][1],
          spatialReference: extent.spatialReference
        };
      }

      function getDatasetField (dataset, fieldName) {
        fieldName = fieldName.toLowerCase();
        const field = dataset.attributes.fields.find(f => f.name.toLowerCase() === fieldName);
        const stats = [...Object.entries(dataset.attributes.statistics).values()].find(([, fields]) => fields[fieldName]);

        // add "simple type" (numeric, date, string) and stats into rest of field definition
        return {
          ...field,
          simpleType: stats && stats[0],
          statistics: stats && stats[1][fieldName].statistics
        }
      }

      const DATASET_FIELD_UNIQUE_VALUES = {}; // cache by field name

      async function getDatasetFieldUniqueValues (dataset, fieldName, layer) {
        if (!DATASET_FIELD_UNIQUE_VALUES[fieldName]) {
          const field = getDatasetField(dataset, fieldName);
          let stats;
          if (field.statistics && field.statistics.uniqueCount) {
            stats = { ...field.statistics };
          } else {
            const uniqueValueInfos = (await uniqueValues({ layer, field: fieldName }))
            .uniqueValueInfos
            .sort((a, b) => a.count > b.count ? -1 : 1);
            const count = uniqueValueInfos.reduce((count, f) => count + f.count, 0);
            stats = {
              count,
              uniqueCount: uniqueValueInfos.length,
              values: uniqueValueInfos
            }
          }

          // add percent of records
          stats.values = stats.values
          // .filter(v => v.value != null && (typeof v.value !== 'string' || v.value.trim() !== ''))
          .map(v => ({ ...v, pct: v.count / stats.count }));

          // get top values
          const maxTopValCount = 12;
          // stats.topValues = stats.values.slice(0, maxTopValCount);
          stats.topValues = [];
          if (stats.uniqueCount < maxTopValCount) {
            stats.topValues = stats.values;
          } else {
            let coverage = 0;
            for (let i=0, coverage=0; i < stats.values.length; i++) {
              // let stat = { ...stats.values[i], pct: stats.values[i].count / recordCount };
              const stat = stats.values[i];
              // if (coverage >= 0.80 && stat.pct < 0.05 && stats.topValues.length >= maxTopValCount) break;
              if (stat.pct < 0.015 || stats.topValues.length >= maxTopValCount) break;
              stats.topValues.push(stat);
              coverage += stat.pct;
            }
          }
          DATASET_FIELD_UNIQUE_VALUES[fieldName] = stats;
        }
        return DATASET_FIELD_UNIQUE_VALUES[fieldName];
      }

      // Determine if field is an integer
      async function datasetFieldIsInteger (field) {
        if (field.type.toLowerCase().includes('integer')) { // explicit integer type
          return true;
        } else { // or check the known values to see if they're all integers
          const stats = await getDatasetFieldUniqueValues(dataset, field.name, layer);
          return stats.values.every(v => v.value == null || Number.isInteger(v.value));
        }
     }

      // Add an entry to the attribute dropdown
      function updateAttributeList (dataset) {
        // create <calcite-dropdown-item> for each attribute
        const attributeList = document.querySelector('#attributeList > calcite-dropdown-group');
        // clear existing entries
        Array.from(attributeList.children)
        .forEach(i => attributeList.removeChild(i))
        const attributes = [
        ...Object.entries(dataset.attributes.statistics.numeric || {}),
        ...Object.entries(dataset.attributes.statistics.date || {}),
        ...Object.entries(dataset.attributes.statistics.string || {})
        ];

        attributes
        .map(([fieldName, { statistics: fieldStats }]) => [fieldName, fieldStats]) // grab stats
        .filter(([fieldName, fieldStats]) => { // exclude fields with one value
          return !fieldStats ||
          !fieldStats.values ||
          fieldStats.uniqueCount > 1 || // unique count reported as 0 for sampled data
          fieldStats.values.min !== fieldStats.values.max
        })
        .forEach(([fieldName, fieldStats]) => {
          // dataset.attributes.fieldNames
          //   .map(fieldName => [fieldName, getDatasetField(dataset, fieldName)])
          //   .filter(([fieldName, field]) => !field.statistics || field.statistics.values.min !== field.statistics.values.max)
          //   .forEach(([fieldName, field]) => {
          const field = getDatasetField(dataset, fieldName);
          // const fieldStats = field.statistics.values;
          const item = document.createElement('calcite-dropdown-item');
          item.innerHTML = `${field.alias || fieldName}`;
          if (fieldStats && fieldStats.values && fieldStats.values.min != null && fieldStats.values.max != null) {
            if (field.simpleType === 'numeric') {
              // TODO: vary precision based on value range
              item.innerHTML += `<br><small>(${fieldStats.values.min.toFixed(2)} to ${fieldStats.values.max.toFixed(2)})</small>`;
            } else if (field.simpleType === 'date') {
              item.innerHTML += ` (${formatDate(fieldStats.values.min)} to ${formatDate(fieldStats.values.max)})`;
            }
          } else if (fieldStats && fieldStats.uniqueCount && field.simpleType === 'string') {
            item.innerHTML += ` (${fieldStats.uniqueCount} values)`;
          }

          // add icon for field type
          if (field.simpleType === 'numeric') {
            item.iconEnd = 'number';
          } else if (field.simpleType === 'string') {
            item.iconEnd = 'description';
          } else if (field.simpleType === 'date') {
            item.iconEnd = 'calendar';
          }

          item.setAttribute('data-field', field.name);
          attributeList.appendChild(item);
        });
        return attributeList;
      }

      async function updateLayerViewEffect(layerView, { where = undefined, updateExtent = false } = {}) {
        layerView.filter = null;

        if (where !== undefined) {
          if (where === null) {
            layerView.effect = null;
          } else {
            layerView.effect = {
              excludedEffect: 'grayscale(100%) opacity(15%)'
            };
          }
        }

        // adjust view extent (in or out) to fit all filtered data
        if (updateExtent) {
          try {
            let featureExtent;

            const queriedExtent = await layer.queryExtent({
              where: (layerView.effect && layerView.effect.filter && layerView.effect.filter.where) || '1=1',
              outSpatialReference: layerView.view.spatialReference
            });

            if (queriedExtent.count > 0) {
              featureExtent = queriedExtent.extent.expand(1.10);
            } else {
              return;
            }

            if (!layerView.view.extent.contains(featureExtent) ||
            (featureExtent.width * featureExtent.height) / (layerView.view.extent.width * layerView.view.extent.height) < 0.20) {
              layerView.view.goTo(featureExtent, { duration: 350 });
            }
          } catch(e) {
            console.log('could not query or project feature extent to update viewport', e);
          }
        }
      }

      async function createHistogram ({dataset, fieldName, layer, layerView, container, slider = false }) {
        // wrap in another container to handle height without fighting w/JSAPI and rest of sidebar
        const parentContainer = container;
        container = document.createElement('div');
        parentContainer.appendChild(container);

        try {
          const params = {
            layer: layer,
            field: fieldName,
            numBins: 30
          };

          let values, source, coverage;
          try {
            values = await generateHistogram(params);
            source = 'widget';
            coverage = 1;
          } catch(e) {
            try {
              // histogram generation failed with automated server call, try using features from server query
              console.log('histogram generation failed with automated server call, try using features from server query');
              params.features = (await layer.queryFeatures()).features;
              const featureCount = await layer.queryFeatureCount();
              values = await generateHistogram(params);
              source = 'layerQuery';
              // coverage = params.features.length / featureCount;
              coverage = 1;
            } catch(e) {
              // histogram generation failed with server call, try using features in layer view
              console.log('histogram generation failed with server call, try using features in layer view');
              params.features = (await layerView.queryFeatures()).features;
              const featureCount = await layer.queryFeatureCount();
              values = await generateHistogram(params);
              source = 'layerView';
              coverage = params.features.length / featureCount;
            }
          }

          // Histogram widget (graph only, no range slider)
          // const histogram = Histogram.fromHistogramResult(values);
          // histogram.container = container;

          // Determine if field is an integer
          const field = getDatasetField(dataset, fieldName);
          const integer = await datasetFieldIsInteger(field);
          let widget;
          if (slider) {
            // Histogram range slider widget
            widget = new HistogramRangeSlider({
              bins: values.bins,
              min: values.minValue,
              max: values.maxValue,
              values: [values.minValue, values.maxValue],
              precision: integer ? 0 : 2,
              container: container,
              excludedBarColor: "#dddddd",
              rangeType: "between",
              labelFormatFunction: (value, type) => {
                // apply date formatting to histogram
                if (field.simpleType == 'date') {
                  return formatDate(value);
                }
                return value;
              }
            });
          } else {
            // plain histogram, for miniHistogram nested in timeSlider
            widget = new Histogram({
              bins: values.bins,
              min: values.minValue,
              max: values.maxValue,
              container: container,
              rangeType: "between",
            });
          }
          return { widget, values, source, coverage };
        }
        catch(e) {
          console.log('histogram generation failed', e);
          return {};
        }
      }

      async function createTimeSlider ({ dataset, fieldName, layerView, container }) {
        try {
          const field = getDatasetField(dataset, fieldName);
          // let {min: startDate, max: endDate } = dataset.attributes.statistics.date[fieldname.toLowerCase()].statistics.values;
          const startDate = new Date(field.statistics.values.min);
          const endDate = new Date(field.statistics.values.max);
          const widget = new TimeSlider({
            container: container,
            //   view: view,
            mode: "time-window",
            fullTimeExtent: {
              start: startDate,
              end: endDate,
            },
            values: [
            startDate,
            endDate
            ],
          });

          // handle play button behavior
          let selectionWasFullExtent;
          widget.watch('viewModel.state', function(state){
            if (state == "playing") {
              // check values (date selection) against fullTimeExtent
              // convert to numeric values with unary + operator to check equivalence (with a 10% tolerance)
              if ( +this.values[0] == +this.fullTimeExtent.start &&
              Math.abs(+this.values[1] - +this.fullTimeExtent.end) <
              (+new Date(this.fullTimeExtent.end) - +new Date(this.fullTimeExtent.start))/ 10 ) {
                // make a note
                selectionWasFullExtent = true;
                // set new selection end to 10% through the date range
                this.values[1] = new Date(+new Date(this.fullTimeExtent.start) + (+new Date(this.fullTimeExtent.end) - +new Date(this.fullTimeExtent.start)) / 10);
              }
            }
            else if (state == "ready" && selectionWasFullExtent) {
              // reset note
              selectionWasFullExtent = false;
              this.values = [this.fullTimeExtent.start, this.fullTimeExtent.end];
            }
          });

          return { widget };
        }
        catch(e) {
          console.log(e);
          return {};
        }
      }

      function formatDate (timestamp) {
        const date = new Date(timestamp);
        return `${date.getMonth()+1}/${date.getDate()}/${date.getFullYear()}`;
      }

      function simpleFieldType (fieldType) {
        const fieldTypes = {
          esriFieldTypeGlobalID: 'text',
          esriFieldTypeGUID: 'text',
          esriFieldTypeDate: 'date-time',
          esriFieldTypeString: 'string',
          esriFieldTypeSingle: 'number',
          esriFieldTypeFloat: 'number',
          esriFieldTypeDouble: 'number',
          esriFieldTypeInteger: 'number',
          esriFieldTypeSmallInteger: 'number',
          esriFieldTypeOID: 'number',
        };

        return fieldTypes[fieldType] || '';
      }

      window.createSmartMapRenderer = createSmartMapRenderer;
      function createSmartMapRenderer (layer, field, view) {
        // Some smart mapping renderers support passing cached statistics, which saves an extra server call.
        // Currently, our uses of `createRenderer` and `createContinuousRenderer` benefit from this.
        // `createClassBreaksRenderer` does not support this parameter but will ignore it.
        const statistics = (field.statistics && field.statistics.duration > 0) ? field.statistics : null;
        const props = {
          layer,
          field: field.name,
          statistics,
          view
        };
        // TOOD: should this use simpleGeomType() to be consistent w/ component's geometryClass?
        const geomType = layer.geometryType;
        const fieldType = simpleFieldType(field.type);
        switch (fieldType) {
          case 'string':
          props.numTypes = 12;
          if (props.statistics) {
            // reformat stats to match `UniqueValuesResult` structure expected by `type` renderers
            props.statistics = { uniqueValueInfos: props.statistics.values };
          }
          return loadRenderer('type', props);
          case 'number':
          if (geomType === 'polygon') {
            return loadRenderer('color', props);
          }
          if (geomType === 'point' || geomType === 'multipoint' || geomType === 'polyline') {
            return loadRenderer('size', props);
          }
          // return reject('Field/geometry type not supported.');
          case 'date-time':
          return loadRenderer('color', props);
          default:
          // return reject('Field type not supported.');
        }
      }

      function loadRenderer (type, props) {
        return loadModules(
        [`esri/renderers/smartMapping/creators/${type}`]
        ).then(([rendererCreator]) => {
          const creatorFn = type === 'color'
          ? 'createContinuousRenderer'
          : type === 'size'
          ? 'createContinuousRenderer' // 'createClassBreaksRenderer'
          : 'createRenderer';
          return rendererCreator[creatorFn](props)
          .then(response => response.renderer);
        });
      }

      // TESTS

      // makeWidget(null, "phenomenonTime");

      function bigBoard(msg, append=true) {
        if (append) {
          msg = document.getElementById('messageDiv').innerHTML + '<br>' + msg;
        }
        document.getElementById('messageDiv').innerHTML = msg;
      }
    })();
  </script>
</head>

<body>
  <div id="sidebar">
    <div id="sidebarItems">

      <select id="datasetList"></select>
      <select id="rampList"></select>
      <select id="themeList"></select>

      <div id="datasetName"></div>
      <div>
        <span id="orgName"></span>
        <span id="recordCount"></span>
      </div>

      <calcite-dropdown type="hover" width="l" id="attributeList">
        <calcite-button id="attributeListButton" slot="dropdown-trigger">Choose an attribute</calcite-button>
        <calcite-dropdown-group>
        </calcite-dropdown-group>
      </calcite-dropdown>

      <div id="widget">
      </div>

      <div id="widgetMessage"></div>

    </div>
  </div>
  <div id="viewDiv"></div>
  <div id="messageDiv" class="esri-widget"></div>
  <!-- <div id="zoomToData" class="esri-widget">
    <label>
      <calcite-checkbox checked="true"></calcite-checkbox>Zoom to data
    </label>
  </div> -->
</body>
</html>
